<!DOCTYPE html>
<html>
<head>
    <title>AgDSS Map</title>

    <link rel="stylesheet" href="/static/scripts/leaflet/leaflet.css"/>

    <!-- Make sure you put this AFTER Leaflet's CSS -->
    <script src="/static/scripts/leaflet/leaflet.js">
    </script>

    <script type="text/javascript" src="/static/scripts/dom-to-image.min.js"></script>

    <link rel="stylesheet" href="/static/scripts/leaflet.draw/leaflet.draw.css"/>
    <script src="/static/scripts/leaflet.draw/leaflet.draw.js"></script>

    <script src="/static/scripts/index.js"></script>
    <script src="/static/scripts/jQuery/jquery-3.0.0.min.js"></script>

    <script type="text/javascript">

        //Global vars:
        var R = 6378137;
        var sphericalScale = 0.5 / (Math.PI * R);

        extractImages = function (map) {
            bounds = map.getBounds();
            //alert(bounds);
            console.log(bounds);
            var zoom = 23;

            //north, west
            var min = project(bounds._northEast.lat, bounds._southWest.lng, zoom);

            //south, east
            var max = project(bounds._southWest.lat, bounds._northEast.lng, zoom);


            console.log(min);
            console.log(max);
            window.location.href = "/app/extract?minx=" + min.x + "&maxx=" + max.x + "&miny=" + min.y + "&maxy=" + max.y;
        };


        function project(lat, lng, zoom) {
            var d = Math.PI / 180,
                max = 1 - 1E-15,
                sin = Math.max(Math.min(Math.sin(lat * d), max), -max),
                scale = 256 * Math.pow(2, zoom);

            var point = {
                x: R * lng * d,
                y: R * Math.log((1 + sin) / (1 - sin)) / 2
            };

            point.x = tiled(scale * (sphericalScale * point.x + 0.5));
            point.y = tiled(scale * (-sphericalScale * point.y + 0.5));

            return point;
        }


        function tiled(num) {
            return Math.floor(num / 256);
        }

    </script>


</head>
<body>

Atlanta Flight Demo: <br/>
<div id="mapid" style="height: 512px; width: 1024px; float:left"></div>
<div style="height: 512px; width: 100px;float: left" id="">
    <form style="margin:15px" id="class_select">
        {% for category_name, color in categories.items %}
            <label style="color:{{ color }}">
                <input type="radio" name="label_class" value="{{ category_name }}">
                {{ category_name }}
            </label><br/>
        {% endfor %}

        <!--<label><input type="radio" class="label_class" value = "amp" checked="true">amp </label><br/>
        <label><input type="radio" name="label_class" value = "tap">tap</label><br/>
        <label><input type="radio" name="label_class" value = "house">house</label><br/>
        <label><input type="radio" name="label_class" value = "car">car</label><br/>
        <label><input type="radio" name="label_class" value = "tree">tree</label><br/>
        <label><input type="radio" name="label_class" value = "road">road</label><br/>-->

    </form>
</div>


<script type="text/javascript">

    {#    var atlantaTiles = L.tileLayer('/static/aerialapps/tiles/{z}/{x}/{y}.png', {#}
    {#      attribution: 'Aerial Apps',#}
    {#      maxZoom: 23,#}
    {#      id: 'mapbox.streets'#}
    {#    });#}
    var atlantaTiles = L.tileLayer('http://label.ag:8051/tiles/{z}/{x}/{y}.png', {
        attribution: 'Aerial Apps',
        maxZoom: 23,
        id: 'mapbox.streets'
    });

    var predictTiles = L.tileLayer('http://label.ag:8051/preds_latest/rgba/{z}/{x}/{y}.png', {
        minZoom: 21,
        maxZoom: 23,
        id: 'mapbox.streets2'
    });
    {#    var predictTiles = L.tileLayer('/static/aerialapps/preds_latest/rgba/{z}/{x}/{y}.png',{#}
    {#      minZoom:21,#}
    {#      maxZoom: 23,#}
    {#      id: 'mapbox.streets2'#}
    {#    });#}


    var map = L.map('mapid', {
        minZoom: 13,
        maxZoom: 23,
        layers: [atlantaTiles, predictTiles]
    });

    map.setView([34.004263688375346, -84.39877241849901], 21);

    //The layer for all the shapes
    var drawnItems = L.featureGroup().addTo(map);

    //Create the draw/edit control
    var drawControl = new L.Control.Draw({
        edit: {
            edit: false,
            featureGroup: drawnItems,
            poly: {
                allowIntersection: false
            }
        },
        draw: {
            polyline: false,
            marker: false,
            circlemarker: false
        }
    });

    drawControl.addTo(map);


    var baseLayers = {};

    var overlays = {
        "Atlanta": atlantaTiles,
        "Labels": drawnItems,
        "Predictions": predictTiles
    };

    L.control.layers(baseLayers, overlays).addTo(map);

    //Initialize the easyPrint module

    var printerOptions = {
        sizeModes: ['Current'],
        filename: 'myMap',
        exportOnly: true,
        position: 'bottomright'
    };


    var printer = L.easyPrint(printerOptions);
    printer.addTo(map);

    draw_shapes = function (geoJson, label_type) {
        if (label_type == "circle") {
            circleLayer = L.circle([geoJson.geometry.coordinates[1], geoJson.geometry.coordinates[0]], geoJson.properties.options);
            drawnItems.addLayer(circleLayer);
        } else if (label_type == "rectangle") {

            var rectLayer = L.rectangle([[geoJson.geometry.coordinates[0][0].slice().reverse(), geoJson.geometry.coordinates[0][1].slice().reverse(),
                geoJson.geometry.coordinates[0][2].slice().reverse(), geoJson.geometry.coordinates[0][3].slice().reverse()]], geoJson.properties.options);
            drawnItems.addLayer(rectLayer);
        } else if (label_type == "polygon") {
            coords = [];
            for (j = 0; j < geoJson.geometry.coordinates.length; j++) {
                coords.push([]);
                for (k = 0; k < geoJson.geometry.coordinates[j].length; k++) {
                    coords[j].push(geoJson.geometry.coordinates[j][k].slice().reverse());
                }
            }
            var polyLayer = L.polygon(coords, geoJson.properties.options);
            drawnItems.addLayer(polyLayer);
        } else {
            var geoJsonLayer = L.geoJSON(geoJson, geoJson.properties.options);
            drawnItems.addLayer(geoJsonLayer);
        }
    };

    //Read the labels in the db and add it to the map
    var xhttp_all = new XMLHttpRequest();
    xhttp_all.onreadystatechange = function () {
        if (this.readyState == 4 && this.status == 200) {
            resp_obj = JSON.parse(this.responseText);
            for (i = 0; i < resp_obj.length; i++) {
                var geoJsonResp = resp_obj[i].geoJSON;
                draw_shapes(geoJsonResp, resp_obj[i].label_type)
            }
        }
    };

    xhttp_all.open("GET", "/webclient/TiledLables", true);
    xhttp_all.send();


    map.on(L.Draw.Event.CREATED, function (event) {
        var layer = event.layer;
        var geoJson = layer.toGeoJSON();

        var ne_lat;
        var ne_lng;
        var sw_lat;
        var sw_lng;

        var propJSON = {};
        if (event.layerType == "circle") {
            console.log(layer);
            layer._map = layer._map || map;
            var bounds = layer.getBounds();
            var northeast = bounds.getNorthEast();
            var southwest = bounds.getSouthWest();
            ne_lat = layer._latlng.lat + layer._mRadius;
            ne_lng = layer._latlng.lng + layer._mRadius;
            sw_lat = layer._latlng.lat - layer._mRadius;
            sw_lng = layer._latlng.lng - layer._mRadius;
            propJSON.latlng = layer._latlng;
            propJSON.radius = layer._mRadius;
            geoJson.properties.shape_type = "circle";
            geoJson.properties.radius = layer._mRadius;
        } else {
            var bounds = layer.getBounds();
            ne_lat = layer._bounds._northEast.lat;
            ne_lng = layer._bounds._northEast.lng;
            sw_lat = layer._bounds._southWest.lat;
            sw_lng = layer._bounds._southWest.lng;
            propJSON.latlngs = layer._latlngs[0];
        }
        geoJson.properties.options = layer.options;

        var radio_label_class = $("input:radio[name=label_class]:checked").val();

        requestObj = {
            northeast_lat: ne_lat,
            northeast_lng: ne_lng,
            southwest_lat: sw_lat,
            southwest_lng: sw_lng,
            zoom_level: map.getZoom(),
            label_type: event.layerType,
            category_name: radio_label_class,
            geoJSON: geoJson,
            propJSON: propJSON
        };
        console.log(requestObj);

        draw_shapes(geoJson, event.layerType);
{#        if (event.layerType == "circle") {#}
{#            circleLayer = L.circle([geoJson.geometry.coordinates[1], geoJson.geometry.coordinates[0]], geoJson.properties.options);#}
{#            drawnItems.addLayer(circleLayer);#}
{#            console.log('geoJson');#}
{##}
{#        } else {#}
{#            var geoJsonLayer = L.geoJSON(geoJson);#}
{#            drawnItems.addLayer(geoJsonLayer);#}
{#        }#}

        //Data to be used for printing of images
        var maskData;
        var imageData;
        var printedImageName;

        centerLatLng = map.getCenter();
        centerXY = project(centerLatLng.lat, centerLatLng.lng, map.getZoom());
        printedImageName = map.getZoom().toString() + "_" + centerXY.x.toString() + "_" + centerXY.y.toString();
        var checkBoxes = document.getElementsByClassName('leaflet-control-layers-selector');

        var xhttp = new XMLHttpRequest();
        xhttp.onreadystatechange = function () {
            if (this.readyState == 4 && this.status == 200) {
                //Print the map
                map.removeLayer(drawnItems);
                printer.printMap('CurrentSize', 'test').then(function (result) {
                    imageData = result;

                    map.addLayer(drawnItems);
                    map.removeLayer(atlantaTiles);

                    printer.printMap('CurrentSize', 'test2').then(function (imResult) {
                        requestObj = {};
                        maskData = imResult;
                        requestObj.image_blob = imageData;
                        requestObj.mask_blob = maskData;
                        requestObj.image_name = printedImageName;
                        requestObj.category_name = radio_label_class;

                        map.addLayer(atlantaTiles);
                        fetch("../webclient/addTiledImage", {
                            body: JSON.stringify(requestObj),
                            headers: {
                                'content-type': 'application/json'
                            },
                            method: 'POST'
                        }).then(function (resp) {
                            console.log(resp)
                        })
                    })
                    //return result;
                })

            }
        };

        xhttp.open("POST", "/webclient/addTiledLabel", true);
        xhttp.setRequestHeader("Content-Type", "application/json");
        xhttp.send(JSON.stringify(requestObj));
    });

    map.on('draw:deleted', function (e) {
        console.log(e);
        var request_obj = [];
        e.layers.eachLayer(function (layer) {
            if (layer instanceof  L.Rectangle) {
                var label_type = "Rectangle";
            }
            else if (layer instanceof L.Circle) {
            //Workaround from https://github.com/Leaflet/Leaflet.draw/issues/701
                layer._map = layer._map || map;
                var label_type = "Circle";
            }
            else if (layer instanceof L.Polygon) {
                var label_type = "Polygon";
            }
            else {
                return //Not one of the possible label types
            }
            console.log(layer._map);
            var bounds = layer.getBounds();
            var northeast = bounds.getNorthEast();
            var southwest = bounds.getSouthWest();
            delete_layer_dict = {
                northeast_lat: northeast.lat,
                northeast_lng: northeast.lng,
                southwest_lat: southwest.lat,
                southwest_lng: southwest.lng,
                label_type: label_type,
                category_name: color_to_category[layer.options.color]
            };
            request_obj.push(delete_layer_dict);
            if (layer._map != null) {
                layer._map.removeLayer(layer);
                console.log(layer);
            }
        });
        console.log(request_obj);

        $.ajax({
            url: "/webclient/deleteTileLabels",
            type: "POST",
            dataType: "text",
            data: JSON.stringify(request_obj),
            success: function (data) {
                console.log(data);
            },
            error: function (data) {
                console.log(data)
            }

        });
    });

    $(document).ready(function () {
        set_label_draw_color = function () {
            var color = $(this).parent().css('color');
            drawControl.setDrawingOptions({
                rectangle: {
                    shapeOptions: {
                        color: color
                    }
                },
                circle: {
                    shapeOptions: {
                        color: color
                    }
                },
                polygon: {
                    shapeOptions: {
                        color: color
                    }
                }
            });
        };
        $("input:radio[name=label_class]").on('change load', set_label_draw_color);
        $("input:radio[name=label_class]:first").attr('checked', true).trigger('change');
        color_to_category = {};
        $("input:radio[name=label_class]").each(function () {
            color_to_category[$(this).parent().css('color')] = $(this).val();
        });


    });
</script>
<br/>

<!--
<button style= "display: block; clear: both;" type="button" onclick="extractImages(mymap)">Extract Images</button>
  -->
</body>
</html>